"""
Ad Serving API Server
Serves personalized ads generated by the v0 pipeline to the Chrome extension.

Usage:
    python ad_server.py
    
Endpoints:
    GET  /api/ad/<user_id>           - Get best ad for user
    GET  /api/ads/<user_id>          - Get all ad variants for user
    POST /api/generate/<user_id>     - Trigger pipeline for user (with context card)
    GET  /api/users                  - List users with cached ads
    GET  /health                     - Health check
"""

import json
import os
from pathlib import Path
from datetime import datetime
from glob import glob
from flask import Flask, jsonify, request
from flask_cors import CORS

app = Flask(__name__)
CORS(app)  # Enable CORS for Chrome extension access

# Directory where pipeline outputs are stored
OUTPUT_DIR = Path(__file__).parent

# In-memory cache: user_id -> {ads, ctr_prediction, timestamp}
ads_cache = {}


def load_latest_result_for_user(username: str) -> dict | None:
    """Load the most recent pipeline result for a user from JSON files."""
    pattern = str(OUTPUT_DIR / f"{username}_*_full_result.json")
    files = glob(pattern)
    
    if not files:
        return None
    
    # Sort by modification time, newest first
    files.sort(key=os.path.getmtime, reverse=True)
    latest_file = files[0]
    
    with open(latest_file, 'r', encoding='utf-8') as f:
        return json.load(f)


def format_ad_for_extension(ad_data: dict, index: int = 0) -> dict:
    """Format ad data for the Chrome extension."""
    rewritten_ads = ad_data.get("remixed_ads", {}).get("rewritten_ads", [])
    ctr_prediction = ad_data.get("ctr_prediction", {})
    
    # Get the best ad based on CTR prediction, or fallback to index
    best_index = ctr_prediction.get("best_ad_index", index)
    
    if not rewritten_ads:
        return None
    
    # Ensure index is valid
    if best_index >= len(rewritten_ads):
        best_index = 0
    
    ad = rewritten_ads[best_index]
    content = ad.get("content", "")
    
    # Parse content to extract title (first line) and description
    lines = content.split('\n')
    title = lines[0].strip() if lines else "Sponsored Ad"
    description = lines[1].strip() if len(lines) > 1 else ""
    
    return {
        "id": f"{ad_data.get('user_id', 'unknown')}_{best_index}",
        "title": title,
        "description": description,
        "full_content": content,
        "image_uri": ad.get("image_uri"),
        "brand": "AI Personalized",
        "avatar": "https://abs.twimg.com/icons/apple-touch-icon-192x192.png",
        "ctr_score": ctr_prediction.get("scores", [{}])[0].get("ctr_mean", 0),
        "confidence": ctr_prediction.get("confidence", 0),
        "ad_index": best_index,
        "total_variants": len(rewritten_ads)
    }


def format_all_ads_for_extension(ad_data: dict) -> list:
    """Format all ad variants for the Chrome extension."""
    rewritten_ads = ad_data.get("remixed_ads", {}).get("rewritten_ads", [])
    ctr_prediction = ad_data.get("ctr_prediction", {})
    scores = ctr_prediction.get("scores", [])
    
    formatted_ads = []
    for i, ad in enumerate(rewritten_ads):
        content = ad.get("content", "")
        lines = content.split('\n')
        title = lines[0].strip() if lines else "Sponsored Ad"
        description = lines[1].strip() if len(lines) > 1 else ""
        
        # Find score for this ad
        score_data = next((s for s in scores if s.get("ad_index") == i), {})
        
        formatted_ads.append({
            "id": f"{ad_data.get('user_id', 'unknown')}_{i}",
            "title": title,
            "description": description,
            "full_content": content,
            "image_uri": ad.get("image_uri"),
            "brand": "AI Personalized",
            "avatar": "https://abs.twimg.com/icons/apple-touch-icon-192x192.png",
            "ctr_score": score_data.get("ctr_mean", 0),
            "confidence": score_data.get("ctr_std", 0),
            "ad_index": i,
            "is_best": i == ctr_prediction.get("best_ad_index", 0)
        })
    
    # Sort by CTR score descending
    formatted_ads.sort(key=lambda x: x["ctr_score"], reverse=True)
    
    return formatted_ads


@app.route("/health")
def health():
    """Health check endpoint."""
    return jsonify({"status": "ok", "timestamp": datetime.now().isoformat()})


@app.route("/api/users")
def list_users():
    """List all users with available ads."""
    pattern = str(OUTPUT_DIR / "*_full_result.json")
    files = glob(pattern)
    
    users = set()
    for f in files:
        filename = os.path.basename(f)
        # Extract username from filename (format: username_timestamp_full_result.json)
        parts = filename.split('_')
        if len(parts) >= 3:
            users.add(parts[0])
    
    return jsonify({
        "users": list(users),
        "cached_users": list(ads_cache.keys())
    })


@app.route("/api/ad/<user_id>")
def get_ad(user_id: str):
    """
    Get the best performing ad for a user.
    
    Query params:
        - variant: int (optional) - specific variant index to return
        - refresh: bool (optional) - force reload from file
    """
    variant = request.args.get("variant", type=int)
    refresh = request.args.get("refresh", "false").lower() == "true"
    
    # Check cache first (unless refresh requested)
    if not refresh and user_id in ads_cache:
        ad_data = ads_cache[user_id]["data"]
    else:
        # Load from file
        ad_data = load_latest_result_for_user(user_id)
        
        if ad_data:
            ads_cache[user_id] = {
                "data": ad_data,
                "timestamp": datetime.now().isoformat()
            }
    
    if not ad_data:
        return jsonify({
            "error": "No ads found for user",
            "user_id": user_id,
            "hint": "Run the pipeline first: python pipeline.py"
        }), 404
    
    # Format for extension
    if variant is not None:
        formatted = format_ad_for_extension(ad_data, index=variant)
    else:
        formatted = format_ad_for_extension(ad_data)
    
    if not formatted:
        return jsonify({"error": "No ad variants available"}), 404
    
    return jsonify(formatted)


@app.route("/api/ads/<user_id>")
def get_all_ads(user_id: str):
    """Get all ad variants for a user, sorted by CTR score."""
    refresh = request.args.get("refresh", "false").lower() == "true"
    
    # Check cache first
    if not refresh and user_id in ads_cache:
        ad_data = ads_cache[user_id]["data"]
    else:
        ad_data = load_latest_result_for_user(user_id)
        
        if ad_data:
            ads_cache[user_id] = {
                "data": ad_data,
                "timestamp": datetime.now().isoformat()
            }
    
    if not ad_data:
        return jsonify({
            "error": "No ads found for user",
            "user_id": user_id
        }), 404
    
    formatted = format_all_ads_for_extension(ad_data)
    
    return jsonify({
        "user_id": user_id,
        "username": ad_data.get("username", user_id),
        "total_ads": len(formatted),
        "ads": formatted,
        "context": {
            "topic": ad_data.get("context_card", {}).get("general_topic", ""),
            "tone": ad_data.get("context_card", {}).get("user_persona_tone", "")
        }
    })


@app.route("/api/generate/<user_id>", methods=["POST"])
def generate_ads(user_id: str):
    """
    Trigger the pipeline to generate new ads for a user.
    
    Request body (JSON):
        - context_card: dict (optional) - existing context card to use
        - user_data: dict (optional) - user data if no context card
    """
    try:
        from pipeline import AdIntelligencePipeline, save_results
        
        data = request.get_json() or {}
        
        pipeline = AdIntelligencePipeline()
        
        if "context_card" in data:
            result = pipeline.run_from_context_card(data["context_card"])
        elif "user_data" in data:
            result = pipeline.run_from_user_data(data["user_data"])
        else:
            return jsonify({
                "error": "Must provide either context_card or user_data"
            }), 400
        
        # Save results
        save_results(result, str(OUTPUT_DIR))
        
        # Update cache
        ads_cache[result.username] = {
            "data": result.to_dict(),
            "timestamp": datetime.now().isoformat()
        }
        
        # Return the best ad
        formatted = format_ad_for_extension(result.to_dict())
        
        return jsonify({
            "success": True,
            "user_id": result.user_id,
            "username": result.username,
            "best_ad": formatted,
            "all_ads": format_all_ads_for_extension(result.to_dict())
        })
        
    except Exception as e:
        return jsonify({
            "error": str(e),
            "type": type(e).__name__
        }), 500


@app.route("/api/ad/random")
def get_random_ad():
    """Get a random ad from any available user (for testing)."""
    pattern = str(OUTPUT_DIR / "*_full_result.json")
    files = glob(pattern)
    
    if not files:
        return jsonify({"error": "No ads available"}), 404
    
    import random
    random_file = random.choice(files)
    
    with open(random_file, 'r', encoding='utf-8') as f:
        ad_data = json.load(f)
    
    formatted = format_ad_for_extension(ad_data)
    return jsonify(formatted)


def get_available_users() -> list:
    """Get list of users with available ads (helper for startup)."""
    pattern = str(OUTPUT_DIR / "*_full_result.json")
    files = glob(pattern)
    
    users = set()
    for f in files:
        filename = os.path.basename(f)
        parts = filename.split('_')
        if len(parts) >= 3:
            users.add(parts[0])
    
    return list(users)


if __name__ == "__main__":
    print("\n" + "="*60)
    print("AD SERVING API SERVER")
    print("="*60)
    print(f"\nServing ads from: {OUTPUT_DIR}")
    print("\nEndpoints:")
    print("  GET  /api/ad/<user_id>       - Get best ad for user")
    print("  GET  /api/ads/<user_id>      - Get all ad variants")
    print("  POST /api/generate/<user_id> - Generate new ads")
    print("  GET  /api/users              - List available users")
    print("  GET  /api/ad/random          - Get random ad (testing)")
    print("  GET  /health                 - Health check")
    print("\n" + "="*60 + "\n")
    
    # List available users on startup
    users = get_available_users()
    if users:
        print(f"Available users: {', '.join(users)}")
    else:
        print("No cached ads found. Run pipeline.py to generate ads.")
    
    print("\nStarting server on http://127.0.0.1:8001")
    print("Press Ctrl+C to stop\n")
    
    app.run(host="127.0.0.1", port=8001, debug=True)
